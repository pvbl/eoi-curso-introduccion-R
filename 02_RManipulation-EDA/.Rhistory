result
all_wwv_res
# Construct star_wars_matrix
vt <- c(460.998, 314.4, 290.475, 247.900, 309.306, 165.8)
result <- matrix(result, nrow = 3, byrow = TRUE,
dimnames = list(c("VIDEOS", "AUDIOS", "CAMARAS"),
c("ESPAÑA", "FUERA-ESPAÑA")))
# The worldwide box office figures
worldwide <- rowSums(result)
# concatenamos el total
all_wwv_res <- cbind(result,worldwide)
all_wwv_res
# Seleccionamos FUERA-DESPAÑA para todo
non_es_all <- total[,2]
# Seleccionamos FUERA-DESPAÑA para todo
non_es_all <- total[,2]
MOBILE <- c(70, 100.34, 90.8)
names(MOBILE)<-c("ESPAÑA","FUERA-ESPAÑA","worldwide")
# Combinamos
total <- rbind(all_wwv_res,MOBILE)
total
# Seleccionamos FUERA-DESPAÑA para todo
non_es_all <- total[,2]
# promedio non-ES
mean(non_es_all)
# Seleccionamos el FUERA-ES para VIDEOS y AUDIOS
non_es_some <- total[1:2,2]
# promedio FUERA-ES para VIDEOS  y AUDIOS
mean(non_es_some)
# division
visitors <- total/5
visitors
vt <- c(460.998, 314.4, 290.475, 247.900, 309.306, 165.8,60.23, 34.34, 2405.435, 233.4, 34.36, 16.65)
vt<-matrix(vt,nrow = 4,byrow = TRUE,  dimnames = list(c("VIDEOS", "AUDIOS", "CAMARAS","MOBILE"),
c("ESPAÑA", "FUERA-ESPAÑA","worldwide")))
# division matricial
visitors <- total/vt
es_visitors <- visitors[,1]
# promedio de es_visitors
mean(es_visitors)
visitors
a1<-matrix(1:12,nrows=3,byrow=TRUE)
a1<-matrix(1:12,nrow=3,byrow=TRUE)
a2<-matrix(1:12,nrow=4,byrow=FALSE)
print(a1)
print(a2)
rowMeans(a1)
rowMeans(a1)
colMeans(a1)
# genero
sex_vector <- c("Hombre", "Mujer", "Mujer", "Hombre", "Hombre")
# lo convertimos a factores
factor_sex_vector <-factor(sex_vector)
factor_sex_vector
sex_vector
factor_sex_vector
# animales
animals_vector <- c("Gato", "Jirafa", "Mono", "Caballo")
factor_animals_vector <- factor(animals_vector)
factor_animals_vector
# temperatura
temperature_vector <- c("Alto", "Bajo", "Alto","Bajo", "Medio")
factor_temperature_vector <- factor(temperature_vector, order = TRUE)
factor_temperature_vector
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector)
# especificamos niveles
levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# vemos el sumario
summary(survey_vector)
summary(factor_survey_vector)
# hombre
male <- factor_survey_vector[1]
# mujer
female <- factor_survey_vector[2]
# Es hombre> mujer?
male > female
# Create speed_vector
speed_vector <- c("medium", "slow", "slow", "medium", "fast")
# Convert speed_vector to ordered factor vector
factor_speed_vector <- factor(speed_vector,ordered=TRUE,levels=c("slow","medium","fast"))
# Print factor_speed_vector
factor_speed_vector
summary(factor_speed_vector)
# Create speed_vector
speed_vector <- c("medium", "slow", "slow", "medium", "fast")
# Convert speed_vector to ordered factor vector
factor_speed_vector <- factor(speed_vector,ordered=TRUE,levels=c("slow","medium","fast"))
# Print factor_speed_vector
factor_speed_vector
summary(factor_speed_vector)
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector,order=TRUE)
# especificamos niveles
levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector,order=TRUE,levels=c("Mujer","Hombre"))
# especificamos niveles
levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector,order=TRUE,levels=c("Mujer","Hombre"))
# especificamos niveles
#levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# hombre
male <- factor_survey_vector[1]
# mujer
female <- factor_survey_vector[2]
# Es hombre> mujer?
male > female
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector,order=TRUE,levels=c("Mujer","Hombre"))
# especificamos niveles
#levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector,order=TRUE,levels=c("M","H"))
# especificamos niveles
#levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector,order=TRUE,levels=c("H","M"))
# especificamos niveles
#levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# hombre
male <- factor_survey_vector[1]
# mujer
female <- factor_survey_vector[2]
# Es hombre> mujer?
male > female
# mujeres, hombres
survey_vector <- c("M", "H", "H", "M", "M")
factor_survey_vector <- factor(survey_vector)
# especificamos niveles
levels(factor_survey_vector) <-c("Hombre","Mujer")
factor_survey_vector
# definimos los vectores
name <- c("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
type <- c("Terrestrial planet", "Terrestrial planet", "Terrestrial planet",
"Terrestrial planet", "Gas giant", "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03, 0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)
# creamos un data frame de los vectores
planets_df <- data.frame(name,type,diameter,rotation,rings)
planets_df
str(planets_df)
planets_df[order(planets_df$diameter),]
order(planets_df$diameter)
planets_df[order(planets_df$diameter),]
planets_df$name
planets_df$type
planets_df["type"]
planets_df$type
# seleccionar los 5 primeros valores de diametros
planets_df[1:5,"diameter"]
# seleccionar todos los anillos
rings_vector <-planets_df[,"rings"]
rings_vector
#seleccionamos todos los planetas con anillos
planets_df[rings_vector, ]
planets_df$constant = 1
planets_df
View(a1)
colMeans(planets_df)
planets_df
mean(planets_df)
mean?
```
apply(planets_df,mean)
apply(planets_df,FUN=mean)
help(apply)
apply(planets_df,c(3,4,5,6),FUN=mean)
sapply(planets_df,c(3,4,5,6),FUN=mean)
sapply(planets_df,FUN=mean)
apply(planets_df,MARGIN=c(3,4,5,6),FUN=mean)
Sapply(planets_df,FUN=mean)
sapply(planets_df,FUN=mean)
apply(planets_df,MARGIN=c(3,4,5),FUN=mean)
planets_df
apply(planets_df,MARGIN=c(3,4),FUN=mean)
apply(planets_df,FUN=mean)
sapply(planets_df,FUN=mean)
apply(planets_df,FUN=mean)
lapply(planets_df,FUN=mean)
sapply(planets_df,FUN=mean)
apply(planets_df,1:2,FUN=mean)
#sapply(planets_df,1:2,FUN=mean)
```
#sapply(planets_df,1:2,FUN=mean)
planets_df[c("name","type","diameter")]
subset(planets_df,planets_df$type=="planets_df")
subset(planets_df,planets_df$type=="Gas Giant")
subset(planets_df,planets_df$type=="Gas giant")
#vector con numeros del 1 al 10
my_vector <- 1:10
# matriz
my_matrix <- matrix(1:9, ncol = 3)
# la lista contiene diferentes elementos
my_list <-list(my_vector,my_matrix)
my_list
my_list <- list(vec=my_vector, mat=my_matrix )
my_list
my_list$vec
my_list
cities <- c("New York", "Paris",
"London", "Tokyo",
"Rio de Janeiro", "Cape Town")
for(city in cities) {
if(nchar(city) == 6) {
break
}
print(city)
}
for(i in 1:length(cities)) {
print(cities[i])
}
for(city in cities) {
if(nchar(city) == 6) {
next
}
print(city)
}
args(sd)
help(sd)
triple <- function(x=1) {
y <-
3 * x
return(y)
}
triple(2)
triple()
a[3]
a<- list(plantes_df,7,seq(1:3))
a<- list(planets_df,7,seq(1:3))
type(planets_df)
class(planets_df)
class(planets_df)=="dat.frame"
class(planets_df)=="data.frame"
subset(a,funcion(x){return class(x)=="data.frame"})
expected_df<-funcion(x){return class(x)=="data.frame"}
expected_df<-funcion(x){class(x)=="data.frame"}
expected_df<-funcion(x){a<-class(x)=="data.frame"; return a}
return class(x)=="data.frame"
subset(a,expected_df)
a<- list(planets_df,7,seq(1:3))
a[3]
class(planets_df)=="data.frame"
expected_df<-funcion(x){
a<- list(planets_df,7,seq(1:3))
a[3]
class(planets_df)=="data.frame"
expected_df<-funcion(x){
subset(a,is.data.frame)
sapply(a,is.data.frame)
a[sapply(a,is.data.frame)]
a<- list(planets_df,7,seq(1:3))
a[3]
class(planets_df)=="data.frame"
expected_df<-funcion(x){
a<- list(planets_df,7,seq(1:3))
a[3]
class(planets_df)=="data.frame"
expected_df<-funcion(x){
a<- list(planets_df,7,seq(1:3))
a[3]
class(planets_df)=="data.frame"
expected_df<-funcion(x){
a<- list(planets_df,7,seq(1:3))
a[3]
class(planets_df)=="data.frame"
a[~ sapply(a,is.data.frame)]
a<- list(planets_df,7,seq(1:3))
a[3]
class(planets_df)=="data.frame"
a[!sapply(a,is.data.frame)]
!sapply(a,is.data.frame)
sapply(a,is.data.frame)
expected_df<-funcion(x){
funcion(x){
funcion(x){
expected_df<-function(x){
return(class(x)=="data.frame")
}
if (n%%2==0){
return(v[v%%2==0])
}
f (n%%2==0){
install.packages("ggplot2")
install.packages("ggplot2")
else{
return(v[v%%2==1])
myfunc<-function(v){
n<-length(v)
if (n%%2==0){
return(v[v%%2==0])
}
else{
return(v[v%%2==1])
}
}
return(v[v%%2==1])
search()
library("ggplot2")
nstalar paquetes - Load packages: library(), require()
result <- require("data.table")
nyc <- list(pop = 8405837,
boroughs = c("Manhattan", "Bronx", "Brooklyn",
"Queens", "Staten Island"),
capital = FALSE)
nyc <- list(pop = 8405837,
boroughs = c("Manhattan", "Bronx", "Brooklyn",
"Queens", "Staten Island"),
capital = FALSE)
str(li)
str(li)
tr(li)
rep(c(8, 6, 4, 2), times = 2)
rep(1:12,times=2)
```{r}
str(append(li, rev(li)))
li <- list(log = TRUE,
ch = "hello",
int_vec = sort(rep(seq(8, 2, by = -2), times = 2)))
str(li)
str(append(li, rev(li)))
setwd("~/freelance/docencia/EOI/clases/introduccion_a_R/01_basicos-R/cursoRbasico/02_RManipulation-EDA")
install.packages("NHANES")
library(NHANES)
library(NHANES)
## MISING DATA?
# NHANES
NHANES
library(dplyr)
glimpse
library(dplyr)
library(tidyverse)
library('rsample')
#install.packages("caTools")
library("tidyverse")
library("NHANES")
library("DataExplorer")
library('rsample')
library('caret')
library(caTools)
nrow(TRAIN)
nrow(TES)
nrow(TRAIN)
nrow(TEST)
library(ggplot2)
#install.packages(c("xgboost","randomForest","rpart","rpart.plot"))
library(rpart)
library(rpart.plot)
library(tidyverse)
library(caret)
library(DataExplorer)
library(randomForest)
library(ggplot2)
library(xgboost)
library('rsample')
url_file = "https://raw.githubusercontent.com/zng489/Decision_trees_and_Random-Forest-madfhantr-/main/madfhantr.csv"
df<- read.csv2(url_file,sep=",")
head(df)
table(df$Dependents)
table(df$CoapplicantIncome)
url_file = "https://raw.githubusercontent.com/zng489/Decision_trees_and_Random-Forest-madfhantr-/main/madfhantr.csv"
df<- read.csv2(url_file,sep=",",dec = ".")
head(df)
str(df)
# ponemos como id el loan_id
rownames(df) <- df$Loan_ID
df$Loan_Status <- as.factor(df$Loan_Status)
df$CoapplicantIncome <- as.numeric(df$CoapplicantIncome)
# convertimos las variables siguientes a factores
# ojo! qué pensáis que falta aquí?
cols_factor <- c("Gender","Married","Dependents","Education","Self_Employed","Property_Area")
df<- df %>%
mutate_each_(funs(factor(.)),cols_factor)
#df$Dependents <- as.factor(df$Dependents, levels=())
df$Loan_ID = NULL
head(df)
str(df)
nrow(df)
summary(df)
plot_missing(df)
```{r}
prop.table(table(df$Loan_Status))
123
library(rsample)
TRAINTEST <- initial_split(df, prop=3/4, strata = "Loan_Status")
train<- training(TRAINTEST)
test<- testing(TRAINTEST)
nrow(train)
nrow(test)
train
tree <- rpart(Loan_Status ~ ., data = train, method = 'class')
tree
rpart.plot
rpart.plot(tree)
tree <- rpart(Loan_Status ~ ., data = train, method = 'class')
tree
library(rsample)
TRAINTEST <- initial_split(df, prop=3/4, strata = "Loan_Status")
train<- training(TRAINTEST)
test<- testing(TRAINTEST)
nrow(train)
nrow(test)
tree <- rpart(Loan_Status ~ ., data = train, method = 'class')
tree <- rpart(Loan_Status ~ ., data = train, method = 'class')
tree
plot(tree)
rpart.plot(tree)
importance <- tree$variable.importance # Equivalente a caret::varImp(tree)
importance <- round(100*importance/sum(importance), 1)
importance[importance >= 1]
train_test_split <- initial_split(df, prop = 3/4, strata = "Loan_Status")
train <- training(train_test_split)
test <- testing(train_test_split)
set.seed(123)
#indexes <- sample(1:nrow(df), 0.8*nrow(df))
#train <- df[indexes,]
#test <- df[-indexes,]
train_test_split <- initial_split(df, prop = 3/4, strata = "Loan_Status")
train <- training(train_test_split)
test <- testing(train_test_split)
nrow(train)
nrow(test)
tree <- rpart(Loan_Status ~ ., data = train, method = 'class')
tree
plot(tree)
rpart.plot(tree)
rpart.rules(tree, style = "tall")
importance <- tree$variable.importance # Equivalente a caret::varImp(tree)
importance <- round(100*importance/sum(importance), 1)
importance[importance >= 1]
varImp(tree,scale = FALSE)
df<- rfImpute(Loan_Status~.,df)
set.seed(123)
indexes <- sample(1:nrow(df), 0.8*nrow(df))
train <- df[indexes,]
test <- df[-indexes,]
modelLookup("rf")
rf
rfmodel <- rf(Loan_Status~.,df)
rfmodel <- rf(Loan_Status~.,df)
rfmodel <- rf(Loan_Status~.,data=df,importance=TRUE,
proximity=TRUE)
rfmodel <- rf(Loan_Status~.,data=df,importance=TRUE,
proximity=TRUE)
rfmodel <- rf(Loan_Status~.,data=df)
rfmodel <- randomForest(Loan_Status~.,data=df)
rfmodel
modelLookup("rf")
ctrl <- trainControl(method = "cv",
number = 5,
classProbs = T,
summaryFunction = twoClassSummary)
loanModel_rf <- train(form = Loan_Status ~ .,
data = train,
trControl = ctrl,
metric = "ROC",
method = "rf")
loanModel_rf
imputer <- preProcess(train, method = c('knnImpute', 'center', 'scale'))
train <- predict(imputer, train)
test <- predict(imputer, test)
ctrl <- trainControl(method = "cv",
number = 5,
classProbs = T,
summaryFunction = twoClassSummary)
loanModel_rf <- train(form = Loan_Status ~ .,
data = train,
trControl = ctrl,
metric = "ROC",
method = "rf")
loanModel_rf
plot(loanModel_rf)
loanModel_rf$bestTune
varImp
varImp(loanModel_rf,scale = FALSE)
ggplot
ggplot(varImp(loanModel_rf,scale = FALSE))
pred <- predict(loanModel_rf, newdata = test)
caret::confusionMatrix(pred, test$Loan_Status)
library(gridExtra)
#install.packages("pdp")
library(pdp)
pdp1 <- partial(loanModel_rf, "ApplicantIncome")
p1 <- plotPartial(pdp1)
pdp2 <- partial(loanModel_rf, c("LoanAmount"))
p2 <- plotPartial(pdp2)
grid.arrange(p1, p2, ncol = 2)
rf <- randomForest(Loan_Status ~ ., data = train)
plot(rf)
caret.xgb <- train(Loan_Status ~ ., method = "xgbTree", data = train,
trControl = trainControl(method = "cv", number = 5))
caret.xgb
caret.xgb$bestTune
confusionMatrix(predict(caret.xgb, newdata = test), test$Loan_Status)
#install.packages("h2o")
library(h2o)
